# 毕设汇报20240201

## 检查迭代是否有效

添加噪声密度验证

![image-20240201105839909](https://img.icvuln.com/202402011058467.png)

结果如下：

```
0.7947205862314343
0 0.0
1 0.0
2 0.0
3 0.0
4 0.0
5 0.0
6 0.0
7 0.0
8 0.0
9 0.0
psnr = 23.69689274017275 ssim = 0.7058177082966003
```

结果表明，当第一次迭代时，k=0，降噪完成时噪声密度已降为0，所以迭代无效

代码端也能发现，在一次迭代过程中，对每一个椒盐噪声都进行了操作，所以这一段为假迭代

## 改进方案

### 优化高密度噪声降噪

依次利用4x4、3x3、2x2格子进行高密度噪声下降

### 迭代条件

每轮迭代统计椒盐噪声个数，降为0则停止迭代

### 降噪逻辑优化

#### 改进前

在一次降噪遍历中，对于所有被检测到的椒盐噪声，匹配相应的结构系数，来进行降噪。

可以理解为在一次遍历中，火力覆盖，去除一切噪声，该噪声是什么类型（不论多么预计的偏离会有多高。比如，2x2格子中有多个噪声，此时处理这些噪声的优先级会与只有一个噪声的优先级等同），这显然没那么合理。

#### 改进方案分析

首先认定3个有效信号点和一个噪声点（即3:1情况）为降噪最优情况，后续的优先级依次为2:2和1:3

那么如果按照优先级顺序去去除噪声，得到的效果应该是最好的。

这里会有一个要注意的地方：当进行过一次3:1情况的降噪后，并不能想当然地觉得已经没有3:1的情况了，因为可能会产生新的3:1情况，这时候如果利用后续优先级进行降噪，也不合理。以此类推，进行过2:2情况的降噪之后，也可能会出现3:1情况。

所以，在每一次迭代的过程中，所使用的迭代方案需要“反复横跳”。

#### 改进后的实验

```
0.7937591787915033
4:  0.45951869066904877
4:  0.45946191463913155
4:  0.45946191463913155
3:  0.2775363745098336
3:  0.27738497176338783
3:  0.27738497176338783
2:  0.1121553694984027
2:  0.10863525564353738
2:  0.1084535723478024
2:  0.10841950672985208
2:  0.10841950672985208
1 17954
1 17954
2 9422
1 2717
1 2717
2 2689
1 2689
2 2676
1 2676
2 2676
3 1241
1 286
1 286
2 92
1 0
1 0
2 0
3 0
psnr = 25.313423396525266 ssim = 0.7610030829347012
```

可以看到最终的效果有提升